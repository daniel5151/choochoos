# New in K4

## UART IRQs

<!-- TODO: james -->

## UART Server(s)

<!-- TODO: james -->

## Re-Execute Kernel without resetting TS-72000

Part of our feedback for K3 was that our kernel could not be re-executed without first reseting the TS-7200. This was a silly oversight on our part, as while we had all the infrastructure in place to support this (i.e: a shutdown routine that disabled and asserted interrupts), we had neglected to clear the Timer2 interrupt when shutting down.

Our kernel is now fully re-executable, and should work without having to reset the TS-7200 between runs.

## A Proper Low-Power Mode Idle Task

As mentioned in our K3 docs, we knew full-well that our empty-looping idle task wasn't the best approach. As such, we've gone back and implemented a proper low-power mode idle "task" directly in the kernel.

As it turns out, this was surprisingly simple to implement:

During kernel initialization, we enable the Halt/Standby magic addresses in the System Controller. This only requires two simple lines of code:
- `*(volatile uint32_t*)(SYSCON_SWLOCK) = 0xaa;`
- `*(volatile uint32_t*)(SYSCON_DEVICECFG) |= 1;`

With this setup out of the way, the entire system can be put into the low power Halt mode by reading from the System Controller's Halt register (i.e: `*(volatile uint32_t*)(SYSCON_HALT);`).

As it turns out, using the System Controller to halt the CPU has a very useful side effect: the CPU does _not_ need to have it's IRQs enabled for the System Controller to wake it up! This means that we can leave the CPU in the regular IRQ-disabled Kernel Mode before entering the Halt state, saving us from having to do any mode-switching assembly shenanigans. When an IRQ eventually arrives, the System Controller will simply "unhalt" the CPU, and it will resume executing instructions directly after the `SYSCON_HALT` read. Critically, the CPU does _not_ jump to the global IRQ handler, which would be quite dangerous, given that the IRQ handler is typically only entered when a user task is preempted.

Thus, our entire "idle task" logic is as simple as:

```cpp
if (/* there is nothing to schedule */) {
    idle_timer = *TIMER3_VAL;                       // read the current time before going idle
    *(volatile uint32_t*)(SYSCON_HALT);             // go idle
    idle_time::counter += idle_timer - *TIMER3_VAL; // update idle time counter after waking up
    // handle the IRQ that just woke the CPU up
    driver::handle_interrupt();
}
```

## Splitting `kernel.cc` into multiple files

- no more kernel singleton class. using namespaces instead
    <!-- TODO: james, pls elaborate on namespace structure -->

- kernel.cc only has init, shutdown, and run loop
- irq_handler and swi_handler are in their own files
- each syscall has it's own file

## FirstUserTask with Priority 0

Prior to K4, the FirstUserTask would always be spawned with a priority of 4. While 4 is a certainty a fun and perfectly respectable number, it's not _really_ the first number to spring that springs to mind when asking the question "What should the FirstUserTask priority be?" As such, starting from K4, we've given the FirstUserTask a much saner priority of 0.

_Note:_ Although it wasn't strictly required, we did go back and fix up some of our old assignments, as some of them relied on the FirstUserTask having a priority of 4.

## Spawning the Nameserver Alongside the FirstUserTask

The Nameserver is quite a _special_ user task, as it's interface implicitly relies on the Nameserver task having a _fixed_ Tid. In our kernel, that fixed Tid happens to be 1.

In previous iterations of our kernel, we would ensure that the Nameserver task had a Tid of 1 by having a implicit requirement that that FirstUserTask must spawn the Nameserver task _before_ spawning any other tasks.

While this approach _worked_, it wasn't very robust, as we would often inadvertently spawn a task prior to the Nameserver, and spend a minute or two wondering why the Nameserver calls were failing. To avoid these sorts of mistakes, and to cut down on some boilerplate, we've opted to spawn the Nameserver _alongside_ the FirstUserTask as part of the kernel setup, thereby ensuring that the Nameserver task both exists, _and_ had the correct TID.

## New Syscalls

As part of our cleanup efforts, we've introduced two new kernel syscalls:

### `Perf`

In K3, we had a somewhat... unpolished approach to outputting idle time measurements. Namely, we would simply `bwprintf` the idle percentage each time the idle task was preempted.

This approach had two serious issues:
- It used busy-wait IO, which seriously hurt system performance.
- It would output idle time diagnostics to the same place on screen, without any regard for the UI of the running application.

To tackle both of these issues, we decided that we needed a mechanism whereby user tasks could query the kernel for system performance information. As such, we decided to introduce a new syscall to our kernel: `Perf`.

`Perf` uses syscall number `9` and has the following C signature: `void Perf(struct perf_t*)`, where `struct perf_t` contains all sorts of useful system performance information. At the moment, `struct perf_t` only contains a single field: `uint32_t idle_time_pct`, which as the name implies, is the current idle time percentage of the system.

With this new Perf syscall, individual userland programs to are able to query and display system performance metrics whenever and however they like!

_One final note_: Prior to K4, our idle time measurement would be show the percentage idle time _from startup_. While this provided some indication of system performance, it made it difficult to spot any sudden changes in system performance. To get a more granular notion of system performance, we've opted to have each call to `Perf` reset the idle time measurement, providing a form of "windowed" idle time measurement, where the window size depends on the frequency at which `Perf` is called.

### `Shutdown`

When working on userland code, we make liberal use of `assert` and `panic(const char* fmt, ...)` to notify us if any of our invariants are broken. Prior to K3, these macros used the regular old `Exit` syscall, which would terminate an individual task if something went wrong. This was _okay_, but it typically resulted in us having to manually restart the TS-7200, as our program would most likely hang once an assertion / panic fired.

At the same time, we found that as our programs became more complex, and spawned more and more long-lived tasks, it became quite difficult to trigger a kernel exit (i.e: by exiting all running tasks).

A clean solution to both these problems was to introduce a new syscall: `Shutdown`.

`Shutdown` uses syscall number `10` and has the following C signature: `void Shutdown(void) __attribute__((noreturn))`.

The kernel's Shutdown handler routine is incredibly simple, simply invoking `kexit`, which triggers the kernel's shutdown sequence, and eventually returns execution back to the Redboot.

We've swapped our `assert` and `panic` routines to use `Shutdown` instead of `Exit`, and have used `Shutdown` directly when implementing the `q` command in our k4 user task.
