# New in K3

In K3, we implemented the clock server, using the `AwaitEvent(int event)`
kernel primitive.


## Interrupt handling and `AwaitEvent`

A new function `_irq_handler` (implemented in assembly), is called when an IRQ
occurs, and acts similarly to `_swi_handler`: the task's context is saved, and
execution is switched back to the kernel. This time, `handle_interrupt` is
called in the kernel, which may move an event-blocked task back to the
`ready_queue`. Then, `_activate_task` returns, and the kernel repeats the
scheduling loop.

The kernel contains an `event_queue`, which is an array of 64 optional `Tid`s.
When a task wants to wait for an interrupt, it calls `AwaitEvent(int eventid)`,
where `eventid` is a number between 0 and 63, corresponding to the interupt of
the same number. The kernel records the `Tid` in the `event_queue` array. In
`handle_interrupt`, if the `event_queue` has a task blocked on the interrupt,
the Tid is removes from `event_queue`, and the task is moved back to the
`ready_queue`. The preempted task remains ready, and thus is put back on the
`ready_queue` as well.

Multiple tasks waiting on the same event is not supported, simply because the
clock and UART servers do not require such functionality.

## Clock server

The clock server is implemented using one timer and two tasks: the server and
notifier. Timer2 is set to fire interrupts every 10 milliseconds, to correspond
to a kernel "tick". The clock server starts up the notifier, and then follows
the usual server pattern: a `Receive()` loop that never blocks.

The notifier runs a simple `AwaitEvent(5)` loop (interrupt 5 is for Timer2
underflow), and then `Send`s to the clock server. The clock server tracks
`current_time`, which is incremented every time the notifier sends a tick.
`Time()` is implemented by simply replying with `current_time`. `Delay()` and
`DelayUntil()` are a bit more involved.

The clock server has a priority queue of delayed tasks (called `pq`), where
tasks that want to wake up sooner have higher priority. When `Delay()` and
`DelayUntil()` are called, the tid of the caller is pushed onto the priority
queue with `tick_threshold` set to the time that the task would like to wake
up.  When the notifier ticks, it pops tasks off `pq` until
`pq.peek()->tick_threshold > current_time`, and replies to them, waking them
up.

`Clock::Shutdown` is an extension to the spec, which cleanly exits the clock
server and notifier. The notifier shuts down if the clock server replies with
`shutdown=true` when the notifier sends a tick. Clean shutdown functionality is
useful for tests, which are expected to terminate quickly.

## Idle task and measurement


