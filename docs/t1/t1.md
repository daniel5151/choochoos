# T1 - Train Control 1

_or: How we Learned to Stop Worrying and Love the Trains_

# Train Control Application

## Operating Instruction

Upon starting the application, the user is asked to enter which track the application is running on (either A or B).

After a brief initialization procedure, the display should look something similar to the following (albeit with more color).

```
CPU Usage (03%) _______________________________________________________________________________

[ 6797] train=58 spd=14 vel= 891mm/s pos=C14 ofst=0mm next=(A04 at t= 6862) error=-0.05s/-44mm
-----------------------------------------------------------------------------------------------
>
-----------------------------------------------------------------------------------------------



Enter the track you'll be using (A or B)
Spawned TrackOracleTask!
Initializing Track...
Stopping all trains...
Setting switch positions...
Track has been initialized!
Ready to accept commands!
t1 commands:
  addtr <train>                   - register a train with the track
  route <train> <sensor> <offset> - route train to given sensor + offset
  tr <train> <speed>              - set a train to a certain speed
  mkloop                          - reset track to have a loop
  q                               - quit

debug commands:
  help                   - prints this help message
  sw <branch> <c|s>      - set a branch to be (c)urved or (s)traight
  rv <train>             - reverse a train (MUST BE AT SPEED ZERO!)
  n <sensor> <offset>    - print the position, normalized
  path <sensor> <sensor> - calculate route between two sensors

max tick delay updated to 16 ticks
```

The display consists of the following components:

- A constantly updating readout of the system's CPU utilization, with a time-series graph showing past values using Unicode block chars
- A status readout for each train registered with the system
- A command prompt
- A scrollable region which displays program output and logging information

The system supports the following commands:

**T1 Assignment Specific Commands:**

Command                           | Description
----------------------------------|--------------------------------------------------------------
`addtr <train>`                   | Registers a train with the track
`route <train> <sensor> <offset>` | Routes a train to the specified sensor + offset
`mkloop`                          | Resets the track's branches to have a loop
`q`                               | Quits the program and return back to RedBoot
`tr <train> <train>`              | Sets the speed of a given train (from 1 - 14, with 0 to stop)

**Additional debug commands:**

Command                  | Description
-------------------------|--------------------------------------------------------------
`help`                   | Prints a brief description of available commands
`sw <branch> <c|s>`      | Sets a given track branch to be (s)traight or (c)urved
`rv <train>`             | Reverses the direction of a given train
`n <sensor> <offset>`    | "Normalizes" a sensor + offset on the track
`path <sensor> <sensor>` | Displays a route between two sensors on the track

## UI

Instead of using raw calls to Uart::{Putc,Putstr,Printf}, we've modularized our UI calls into a dedicated UI module, which provides methods and macros for outputting data to the screen in a structured and orderly fashion. Some of the methods and macros the UI module exposes include:

- `log_line`, `log_success`, `log_warning`, `log_error`, etc...
    - `printf`-like macros which display colored output to the UI's log
- `prompt_user(int uart, char* buf, size_t len)`
    - Responsible for drawing the command prompt, and accepting user input.
- `render_train_descriptor(int uart, const train_descriptor_t& td)`
    - Renders a readout of a particular train's state given it's train descriptor
- `void render_initial_screen(int uart, const TermSize& term_size);`
    - Renders any static UI elements which will not change throughout the program's lifetime
    - Uses terminal dimensions to lay out UI elements
        - Dimensions are determined using a VT100 cursor position query

## Initialization

The `FirstUserTask` starts off by executing various mundane, program-agnostic setup routines:
- Spawning the Uart and Clock servers
- Clearing the terminal, and querying it's dimensions
- Spawning the CPU Idle Time task

Once the basic system is up-and-running, FirstUserTask calls the `t1_main` method, which encapsulates any and all T1-specific initialization logic:
- `render_initial_screen` is called, painting the T1 UI
- Prompts the user to enter which track the program will be running on

At this point, the T1 application is ready to begin in earnest.
`FirstUserTask` goes ahead and spawns the two central tasks which implement T1's functionality: The `TrackOracle` and `CmdTask`.

## `TrackOracle`

- Encapsulates all trainset I/O
- maintains an internal representation of the track
    - automatically queries tainset for track updates
    - interpolates train positions
- Does _not_ implement any high-level train control logic. instead, provides primitives for other tasks to build off of

### Interface

- exposes simple methods for
    - setting train speed,
    - setting train direction,
    - switching branches
    - querying branch state
    - querying train status (both pre-set and extrapolated)
- basic methods provide enough functionality to duplicate K4
- advanced functionality requires "registering" trains with the oracle (using `calibrate_train`) method
- also provides powerful primitive for building "smart" train tasks: `wake_at_pos`
    - given a train ID and position on the track, blocks the task until the train hits the position on the track
    - returns a true if the wakeup was successful, or false if the state of the track has changed such-that the train will never reach the specified position

### Key data structures

- track state:
    - TrackGraph - static model of track
    - branches array - dynamic track state
        - TODO: we really aught to make the TrackGraph a non-static structure, and have it know about branch state (instead of jankilly having to pass it via it's interface. not necessarily something we need to do for this deadline, but something to keep in mind)
    - talk about all the cool methods on it, like next/prev sensor, Dijkstra's, normalization, etc...

- train descriptors
    - include fixed train params (id, speed)
    - also stores computed params (velocity, last known position, expected next sensor)

- blocked_task queue
    - currently only supports a single task (i.e: it's just an std::optional)
    - stores tid, train id, and position the tid should be woken up at

- tick delay

### Implementation

- under the hood, TrackOracle spawns a separate task
- similarly to Uart and Clock, user-facing API simply provides methods which wrap Send calls to the task
- task accepts messages, marshal requests as arguments to methods on `TrackOracleImpl`, and marshals return values back to calling task

- calibrate train implementation
    - ask user to place train on track
    - assume that next sensor hit is the specified train position
    - instantiates train descriptor


- Talk about background tasks (tick, sensors)
    - TODO: Should be move the sensor loop out of FirstUserTask? Probably not the best place for it tbh...
- discuss sensor attribution

- discuss wake_at_pos implementation






## `CmdTask`

The `CmdTask` is the task responsible for reading, parsing, and executing user commands.

Specifically, it runs a very simple loop:

1. call the `prompt_user` UI method
2. parse the provided input as a `Command` structure
3. execute the requested command

The `Command` parser was ported over from K4, and has been extended with new commands.

Executing commands is done in-task, either inline, or by calling a separate method which implements the command's logic.

Most of the commands have fairly trivial implementations, whereby the command's arguments are marshalled to the corresponding `TrackOracle` method. e.g: the `tr` command simply calls the `TrackOracle::set_train_speed` method, etc...

Instead of discussing each commands implementation, this documentation will only discuss the implementation details on non-trivial commands, namely: the `route` command.

### `route` command

The `route` command implements the main deliverable of T1: the ability to route a train to a specific point on the track.

At a high level, this command is implemented as follows:

1. Query the train's current position on the track via the `TrackOracle`
2. Run Dijkstra's algorithm to find the shortest path from the train's current position to the specified position on the track
    - _NOTE:_ if no path could be found, _and the train is currently stopped_, attempt to reverse the train, and re-run pathfinding.
3. Assuming a path was found, we traverse the path (given as a series of `train_node` structures) and determine which direction each of the branches along the path should have.
4. Switch all the branches to the correct position
    - _See the "Future Work" section below for some discussion on how we plan to transition to a "Just in Time" model._
5. (optionally) If the path is quite long, set the train speed to 14, and schedule a `wake_at_pos` call to slow the train down as it approaches it's destination (to speed 8)
6. Schedule a `wake_at_pos` call to send a stop command once it's "stopping distance" away from the destination
    - The specific stopping distance is determined using our calibration data, and varies by train

In our current implementation, we treat two sensors at the same position on the track as two separate nodes, each with a different route to them. Namely, when routing to a sensor, the train will attempt to stop at the sensor "head-on", which varies by the sensor's direction.

#### Known Issues

- At the moment, the route command doesn't support "short" paths, namely, those where the distance to the destination node is shorter than a train's stopping distance. This is because we currently do not have a very detailed model of train acceleration and deceleration curved, which would be required to accurately "inch" a train forward towards it's destination.

#### Future work

In our architecture, it should be fairly straightfoward to flip the switches "Just in Time" by using the `wake_at_pos` primitive, whereby the task is woken up just before it hits a branch. This is complicated by the fact that these `wake_at_pos` calls need to be scheduled with respect to the `wake_at_pos` calls which slow/stop the train. Interleaving these `wake_at_pos` calls requires knowing the distance each node is along the path, which is information that is not currently returned by our pathfinding method.

# Train Measurement - Collection

To perform our measurements, we created a new target executable called `measure`. While this executable does in-fact run on top of our operating system, we never spawn more than one task, and only ever invoke the "Exit" and "Shutdown" syscalls. All I/O is done via polling and busy-waiting, as using the UART servers for I/O would add additional overhead when reading / writing data, interfering with the precise timing measurements.

The `measure` target encapsulates all the various tests we run (such as stopping distance, steady-state velocity measurements, etc...), and provides some basic test-agnostic initialization code:

## Initialization

Upon launching `measure`, the program will ask the user which train they will be testing, and a "start speed" to perform automated tests from. This is useful, as the automated tests can occasionally fail mid-way through the test (e.g: lower speeds might stall the train), and need to be restarted from a set speed.

Additionally, the program asks the user if the track should be reset (i.e: stop all trains, and make a large outer loop), as back-to-back tests might not require resetting the track. The `measure` program does _not_ use the CTS flag, and resetting the track can be quite slow.

`measure` uses Timer 3 running at 508khz for measurements. It does _not_ need to manually reset the timer, as our kernel is responsible for setting up timer 3.

## Logging and Exfiltration

Our tests dump measurements to the screen as JSON, with debug lines prepended with a `//` for easy filtering.

We opted to use gtkterm's built-in "save-to-log" functionality to save UART2 output to a file. While this did result in some stray redboot output being saved to our logs, it isn't too difficult to filter out these lines manually.

To get the logs off the train PCs, we simply SCP'd the raw log files to our home directories on the UW CS servers. After a bit of manual cleanup, we were left with some pristine JSON files that contained all the juicy measurement data that we collected.

## Tests

We developed two different test routines to collect information about the trains: a steady-state velocity test, and a stopping distance test.

By the T1 submission deadline, we were able to collect the following data sets:
- Steady-State Velocity for **speeds 5 through 14** for **all** trains
- Stopping Distance measurements for **speeds 8 and 14** for **all** trains

### Steady-State Velocity

This test measures the average steady-state velocity of each train at the given speed settings.

The test methodology is as follows:

1. Set the train going at the desired speed
2. Busy-poll for sensor updates, logging a line with the sensor + timestamp when a sensor is triggered
    - Line has the format of `R"({"event":"sensor","speed":%hhu,"sensor":"%c%hhu","time":%lu},)"`

3. After \~13 seconds (a fairly arbitrary amount), wait until one-last sensor is triggered
4. Bring the train up to speed 14, and wait for it to hit a particular sensor on the outer loop
5. Send the stop command to halt the train

Steps 4 and 5 are useful to automatically bring the train back to a specific known location on the train set. In fact, the first run of the steady-state velocity test doesn't actually record any data, and is solely performed to "calibrate" the train to an expected state!

### Stopping Distance

This test measures the distance a train covers when it is stopped. The test
gets the train up to a steady state-state speed, and then waits for a specific
sensor to be hit. As soon as the sensor is observed, a `speed=0` command is
sent, and the train comes to a stop. At this point the train's stopping
distance can be measured.

An additional mechanism allows "stopping time" to be measured. The program
records the time when the stop command is sent, and then waits for any key to
be pressed by the user. When the user presses a key, the time is recorded and
added to the outputted measurements. This way, is the user is attentive, they
can press a key as soon as they see the train reach a stop, giving a decent
measurement for stopping time.

We measured stopping distance for every train at speeds 14 and 8.

# Train Measurement - Analysis and Integration

We wrote a python script (the aptly named `process.py`) to process the raw
measurement data and emit calibration data. The script parses the two
measurement files for each train, and turns the raw data into expected
velocities and stopping distances.

For velocity, the distances between each successive sensor is combined with the
time difference to produce a bunch of average velocities. We found that aside
from the first few data points (when a train is accelerating), we observed
pretty consistent measurements. So for each train, at each speed level, the
expected velocity is the median velocity observed during the measurements.

Stopping distance uses the mean of the measurements for each train/speed
combination. We found stopping distances at speed 14 to be highly variable, but
at speed 8 to be quite reliable. Both are included in the generated calibration
code, but we only rely on the speed 8 stopping distance when trying to
accurately stop a train.

The python scripts emits `src/raw_calibration/calibration.c` and an associated
header file. This is then loaded by `src/assignments/t1/calibration.cc` where
it the raw data is exposed through a friendly interface:

```cpp
namespace Calibration {
int /* mm/s */ expected_velocity(uint8_t train, uint8_t speed);
int /* mm */ stopping_distance(uint8_t train, uint8_t speed);
int /* ticks */ stopping_time(uint8_t train, uint8_t speed);
int /* ticks */ acceleration_time(uint8_t train,
                                  int current_velocity,
                                  uint8_t target_speed);
}  // namespace Calibration
```


# Future Work

- The framework is set up, and the possibilities are there. The limiting factor is time!
    - good framework for integrating new measurements
    - (we believe) the primitive is good

- refining and improving measurements
- big code cleanup before next assignment
    - deadlines => write-only code
    - better separation of concerns
    - less C, more C++ isms
    - make the UI nicer at some point???
