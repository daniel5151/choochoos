# T1 - Train Control 1

_or: How we Learned to Stop Worrying and Love the Trains_

# Train Control Application

## Operating Instruction

Upon starting the application, the user is asked to enter which track the application is running on (either A or B).

After a brief initialization procedure, the display should look something similar to the following (albeit with more color).

```
CPU Usage (03%) _______________________________________________________________________________

[ 6797] train=58 spd=14 vel= 891mm/s pos=C14 ofst=0mm next=(A04 at t= 6862) error=-0.05s/-44mm
-----------------------------------------------------------------------------------------------
>
-----------------------------------------------------------------------------------------------



Enter the track you'll be using (A or B)
Spawned TrackOracleTask!
Initializing Track...
Stopping all trains...
Setting switch positions...
Track has been initialized!
Ready to accept commands!
t1 commands:
  addtr <train>                   - register a train with the track
  route <train> <sensor> <offset> - route train to given sensor + offset
  tr <train> <speed>              - set a train to a certain speed
  mkloop                          - reset track to have a loop
  q                               - quit

debug commands:
  help                   - prints this help message
  sw <branch> <c|s>      - set a branch to be (c)urved or (s)traight
  rv <train>             - reverse a train (MUST BE AT SPEED ZERO!)
  n <sensor> <offset>    - print the position, normalized
  path <sensor> <sensor> - calculate route between two sensors

max tick delay updated to 16 ticks
```

The display consists of the following components:

- A constantly updating readout of the system's CPU utilization, with a time-series graph showing past values using Unicode block chars
- A status readout for each train registered with the system
- A command prompt
- A scrollable region which displays program output and logging information

The system supports the following commands:

**T1 Assignment Specific Commands:**

Command                           | Description
----------------------------------|--------------------------------------------------------------
`addtr <train>`                   | Registers a train with the track
`route <train> <sensor> <offset>` | Routes a train to the specified sensor + offset
`q`                               | Quits the program and return back to RedBoot
`tr <train> <train>`              | Sets the speed of a given train (from 1 - 14, with 0 to stop)

**Additional debug commands:**

Command                  | Description
-------------------------|--------------------------------------------------------------
`help`                   | Prints a brief description of available commands
`sw <branch> <c|s>`      | Sets a given track branch to be (s)traight or (c)urved
`rv <train>`             | Reverses the direction of a given train
`n <sensor> <offset>`    | "Normalizes" a sensor + offset on the track
`path <sensor> <sensor>` | Displays a route between two sensors on the track

## UI

Instead of using raw calls to Uart::{Putc,Putstr,Printf}, we've modularized our UI calls into a dedicated UI module, which provides methods and macros for outputting data to the screen in a structured and orderly fashion. Some of the methods and macros the UI module exposes include:

- `log_line`, `log_success`, `log_warning`, `log_error`, etc...
    - `printf`-like macros which display colored output to the UI's log
- `prompt_user(int uart, char* buf, size_t len)`
    - Responsible for drawing the command prompt, and accepting user input.
- `render_train_descriptor(int uart, const train_descriptor_t& td)`
    - Renders a readout of a particular train's state given it's train descriptor
- `void render_initial_screen(int uart, const TermSize& term_size);`
    - Renders any static UI elements which will not change throughout the program's lifetime
    - Uses terminal dimensions to lay out UI elements
        - Dimensions are determined using a VT100 cursor position query

## Initialization

The `FirstUserTask` starts off by executing various mundane, program-agnostic setup routines:
- Spawning the Uart and Clock servers
- Clearing the terminal, and querying it's dimensions
- Spawning the CPU Idle Time task

Once the basic system is up-and-running, FirstUserTask calls the `t1_main` method, which encapsulates any and all T1-specific initialization logic:
- `render_initial_screen` is called, painting the T1 UI
- Prompts the user to enter which track the program will be running on

At this point, the T1 application is ready to begin in earnest.
`FirstUserTask` goes ahead and spawns the two central tasks which implement T1's functionality: The `TrackOracle` and `CmdTask`.

## `TrackOracle`

- Encapsulates all trainset I/O
- maintains an internal representation of the track
    - automatically queries tainset for track updates
    - interpolates train positions
- Does _not_ implement any high-level train control logic. instead, provides primitives for other tasks to build off of

### Interface

- exposes simple methods for
    - setting train speed,
    - setting train direction,
    - switching branches
    - querying branch state
    - querying train status (both pre-set and extrapolated)
- basic methods provide enough functionality to duplicate K4
- advanced functionality requires "registering" trains with the oracle (using `calibrate_train`) method
- also provides powerful primitive for building "smart" train tasks: `wake_at_pos`
    - given a train ID and position on the track, blocks the task until the train hits the position on the track
    - returns a true if the wakeup was successful, or false if the state of the track has changed such-that the train will never reach the specified position

### Key data structures

- track state:
    - TrackGraph - static model of track
    - branches array - dynamic track state
        - TODO: we really aught to make the TrackGraph a non-static structure, and have it know about branch state (instead of jankilly having to pass it via it's interface. not necessarily something we need to do for this deadline, but something to keep in mind)
    - talk about all the cool methods on it, like next/prev sensor, Dijkstra's, normalization, etc...

- train descriptors
    - include fixed train params (id, speed)
    - also stores computed params (velocity, last known position, expected next sensor)

- blocked_task queue
    - currently only supports a single task (i.e: it's just an std::optional)
    - stores tid, train id, and position the tid should be woken up at

- tick delay

### Implementation

- under the hood, TrackOracle spawns a separate task
- similarly to Uart and Clock, user-facing API simply provides methods which wrap Send calls to the task
- task accepts messages, marshal requests as arguments to methods on `TrackOracleImpl`, and marshals return values back to calling task

- calibrate train implementation
    - ask user to place train on track
    - assume that next sensor hit is the specified train position
    - instantiates train descriptor


- Talk about background tasks (tick, sensors)
    - TODO: Should be move the sensor loop out of FirstUserTask? Probably not the best place for it tbh...
- discuss sensor attribution

- discuss wake_at_pos implementation






## `CmdTask`

The `CmdTask` is the task responsible for reading, parsing, and executing user commands.

The majority of it's parsing logic has been ported over from past assignments (notably K4), and expanded upon with new commands.

- Trivial commands have straightforward impls (tr, rv, sw, etc...)
- addtr - adds train to track (see docs above)
- route - routes a train to some part of the track

### Train Routing

- query the train's current position on the track from the oracle
- run dijkstra's to find the shortest path
- if no path is found, the train might have to be reversed
    - only reverse if the train is stopped, and then re-run pathfinding
- traverse the path (as a series of nodes) to determine which direction branches need to be switched
- immediately flip all the branches
- use wake_at_pos to wake the train up at the correct time to send stop command (using calibration data)

- _kinda jank atm_, set train to speed 14 on longer routes, before dropping speed to 8 closer to the destination

#### Future work

- "JIT" switching of branches
    - should be possible to implement using wake_at_pos primitive
    - requires pre-calculating all wake_at_pos instances, as it needs to take into account the slowing down / stopping checkpoints as well

# Train Measurement - Collection

<!-- TODO: expand -->

- code is in the "measure" assignment (TODO: merge this into T1 branch)
- doesn't use OS for anything - everything is busy-wait
    - timing uses TIMER3 at 508khz (automatically set up by the kernel)
- program will query user to enter train to test, and which speed to start testing from (needed to compensate for train getting stuck and messing up the results)
- also queries the user is the track should be reset (i.e: stop all trains, set up track to have single large outer-loop)
- data is dumped to screen as JSON
- use terminal's logging functionality to dump data to file
- scp data to student environment
- requires a little bit of manual cleanup, to get rid of stray redboot messages, and debug lines (prepended with //)
- performed two different measurement types: (each of us discusses the test program we wrote)
    - steady-state speed - all trains, all speeds from 14 - 5
        - improve repeatability by "calibrating" the train between runs
        - i.e: once data is collected, bring the train up to speed 14, wait for it to hit a specific sensor, send stop command
        - results in train starting each test from the same point
        - for each speed:
            - send the speed command
            - busy-poll sensors, recording a line with format:
                - `R"({"event":"sensor","speed":%hhu,"sensor":"%c%hhu","time":%lu},)`
            - run train for 13 seconds
            - once 13 seconds are up, wait for the train to hit at least one more sensor
                - useful for lower-speeds, to ensure we get additional data points
    - stopping distance
        - TODO: jams

- mention that we didn't collect stop distance for each speed

# Train Measurement - Analysis and Integration

- TODO: jams

# Future Work

- The framework is set up, and the possibilities are there. The limiting factor is time!
    - good framework for integrating new measurements
    - (we believe) the primitive is good

- refining and improving measurements
- big code cleanup before next assignment
    - deadlines => write-only code
    - better separation of concerns
    - less C, more C++ isms
    - make the UI nicer at some point???
