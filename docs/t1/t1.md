# T1 - Train Control 1

_or: How we Learned to Stop Worrying and Love the Trains_

# Train Control Application

## Operating Instruction

Upon starting the application, the user is asked to enter which track the application is running on (either A or B).

After a brief initialization procedure, the display should look something similar to the following (albeit with more color).

```
CPU Usage (03%) _______________________________________________________________________________

[ 6797] train=58 spd=14 vel= 891mm/s pos=C14 ofst=0mm next=(A04 at t= 6862) error=-0.05s/-44mm
-----------------------------------------------------------------------------------------------
>
-----------------------------------------------------------------------------------------------



Enter the track you'll be using (A or B)
Spawned TrackOracleTask!
Initializing Track...
Stopping all trains...
Setting switch positions...
Track has been initialized!
Ready to accept commands!
t1 commands:
  addtr <train>                   - register a train with the track
  route <train> <sensor> <offset> - route train to given sensor + offset
  tr <train> <speed>              - set a train to a certain speed
  mkloop                          - reset track to have a loop
  q                               - quit

debug commands:
  help                   - prints this help message
  sw <branch> <c|s>      - set a branch to be (c)urved or (s)traight
  rv <train>             - reverse a train (MUST BE AT SPEED ZERO!)
  n <sensor> <offset>    - print the position, normalized
  path <sensor> <sensor> - calculate route between two sensors

max tick delay updated to 16 ticks
```

The display consists of the following components:

- A constantly updating readout of the system's CPU utilization, with a time-series graph showing past values using Unicode block chars
- A status readout for each train registered with the system
- A command prompt
- A scrollable region which displays program output and logging information

The system supports the following commands:

**T1 Assignment Specific Commands:**

Command                           | Description
----------------------------------|--------------------------------------------------------------
`addtr <train>`                   | Registers a train with the track
`route <train> <sensor> <offset>` | Routes a train to the specified sensor + offset
`q`                               | Quits the program and return back to RedBoot
`tr <train> <train>`              | Sets the speed of a given train (from 1 - 14, with 0 to stop)

**Additional debug commands:**

Command                  | Description
-------------------------|--------------------------------------------------------------
`help`                   | Prints a brief description of available commands
`sw <branch> <c|s>`      | Sets a given track branch to be (s)traight or (c)urved
`rv <train>`             | Reverses the direction of a given train
`n <sensor> <offset>`    | "Normalizes" a sensor + offset on the track
`path <sensor> <sensor>` | Displays a route between two sensors on the track

## UI

Instead of using raw calls to Uart::{Putc,Putstr,Printf}, we've modularized our UI calls into a dedicated UI module, which provides methods and macros for outputting data to the screen in a structured and orderly fashion. Some of the methods and macros the UI module exposes include:

- `log_line`, `log_success`, `log_warning`, `log_error`, etc...
    - `printf`-like macros which display colored output to the UI's log
- `prompt_user(int uart, char* buf, size_t len)`
    - Responsible for drawing the command prompt, and accepting user input.
- `render_train_descriptor(int uart, const train_descriptor_t& td)`
    - Renders a readout of a particular train's state given it's train descriptor
- `void render_initial_screen(int uart, const TermSize& term_size);`
    - Renders any static UI elements which will not change throughout the program's lifetime
    - Uses terminal dimensions to lay out UI elements
        - Dimensions are determined using a VT100 cursor position query

## Initialization

The `FirstUserTask` starts off by executing various mundane, program-agnostic setup routines:
- Spawning the Uart and Clock servers
- Clearing the terminal, and querying it's dimensions
- Spawning the CPU Idle Time task

Once the basic system is up-and-running, FirstUserTask calls the `t1_main` method, which encapsulates any and all T1-specific initialization logic:
- `render_initial_screen` is called, painting the T1 UI
- Prompts the user to enter which track the program will be running on

At this point, the T1 application is ready to begin in earnest.
`FirstUserTask` goes ahead and spawns the two central tasks which implement T1's functionality: The `TrackOracle` and `CmdTask`.

## `TrackOracle`

- Encapsulates all trainset I/O
- maintains an internal representation of the track
    - automatically queries tainset for track updates
    - interpolates train positions
- Does _not_ implement any high-level train control logic. instead, provides primitives for other tasks to build off of

### Interface

- exposes simple methods for
    - setting train speed,
    - setting train direction,
    - switching branches
    - querying branch state
    - querying train status (both pre-set and extrapolated)
- basic methods provide enough functionality to duplicate K4
- advanced functionality requires "registering" trains with the oracle (using `calibrate_train`) method
- also provides powerful primitive for building "smart" train tasks: `wake_at_pos`
    - given a train ID and position on the track, blocks the task until the train hits the position on the track
    - returns a true if the wakeup was successful, or false if the state of the track has changed such-that the train will never reach the specified position

### Key data structures

- track state:
    - TrackGraph - static model of track
    - branches array - dynamic track state
        - TODO: we really aught to make the TrackGraph a non-static structure, and have it know about branch state (instead of jankilly having to pass it via it's interface. not necessarily something we need to do for this deadline, but something to keep in mind)
    - talk about all the cool methods on it, like next/prev sensor, Dijkstra's, normalization, etc...

- train descriptors
    - include fixed train params (id, speed)
    - also stores computed params (velocity, last known position, expected next sensor)

- blocked_task queue
    - currently only supports a single task (i.e: it's just an std::optional)
    - stores tid, train id, and position the tid should be woken up at

- tick delay

### Implementation

- under the hood, TrackOracle spawns a separate task
- similarly to Uart and Clock, user-facing API simply provides methods which wrap Send calls to the task
- task accepts messages, marshal requests as arguments to methods on `TrackOracleImpl`, and marshals return values back to calling task

- calibrate train implementation
    - ask user to place train on track
    - assume that next sensor hit is the specified train position
    - instantiates train descriptor


- Talk about background tasks (tick, sensors)
    - TODO: Should be move the sensor loop out of FirstUserTask? Probably not the best place for it tbh...
- discuss sensor attribution

- discuss wake_at_pos implementation






## `CmdTask`

The `CmdTask` is the task responsible for reading, parsing, and executing user commands.

The majority of it's parsing logic has been ported over from past assignments (notably K4), and expanded upon with new commands.

- Trivial commands have straightforward impls (tr, rv, sw, etc...)
- addtr - adds train to track (see docs above)
- route - routes a train to some part of the track

### Train Routing

- query the train's current position on the track from the oracle
- run dijkstra's to find the shortest path
- if no path is found, the train might have to be reversed
    - only reverse if the train is stopped, and then re-run pathfinding
- traverse the path (as a series of nodes) to determine which direction branches need to be switched
- immediately flip all the branches
- use wake_at_pos to wake the train up at the correct time to send stop command (using calibration data)

- _kinda jank atm_, set train to speed 14 on longer routes, before dropping speed to 8 closer to the destination

#### Future work

- "JIT" switching of branches
    - should be possible to implement using wake_at_pos primitive
    - requires pre-calculating all wake_at_pos instances, as it needs to take into account the slowing down / stopping checkpoints as well

# Train Measurement - Collection

To perform our measurements, we created a new target executable called `measure`. While this executable does in-fact run on top of our operating system, we never spawn more than one task, and only ever invoke the "Exit" and "Shutdown" syscalls. All I/O is done via polling and busy-waiting, as using the UART servers for I/O would add additional overhead when reading / writing data, interfering with the precise timing measurements.

The `measure` target encapsulates all the various tests we run (such as stopping distance, steady-state velocity measurements, etc...), and provides some basic test-agnostic initialization code:

## Initialization

Upon launching `measure`, the program will ask the user which train they will be testing, and a "start speed" to perform automated tests from. This is useful, as the automated tests can occasionally fail mid-way through the test (e.g: lower speeds might stall the train), and need to be restarted from a set speed.

Additionally, the program asks the user if the track should be reset (i.e: stop all trains, and make a large outer loop), as back-to-back tests might not require resetting the track. The `measure` program does _not_ use the CTS flag, and resetting the track can be quite slow.

`measure` uses Timer 3 running at 508khz for measurements. It does _not_ need to manually reset the timer, as our kernel is responsible for setting up timer 3.

## Logging and Exfiltration

Our tests dump measurements to the screen as JSON, with debug lines prepended with a `//` for easy filtering.

We opted to use gtkterm's built-in "save-to-log" functionality to save UART2 output to a file. While this did result in some stray redboot output being saved to our logs, it isn't too difficult to filter out these lines manually.

To get the logs off the train PCs, we simply SCP'd the raw log files to our home directories on the UW CS servers. After a bit of manual cleanup, we were left with some pristine JSON files that contained all the juicy measurement data that we collected.

## Tests

We developed two different test routines to collect information about the trains: a steady-state velocity test, and a stopping distance test.

By the T1 submission deadline, we were able to collect the following data sets:
- Steady-State Velocity for **speeds 5 through 14** for **all** trains
- Stopping Distance measurements for **speeds 8 and 14** for **all** trains

### Steady-State Velocity

This test measures the average steady-state velocity of each train at the given speed settings.

The test methodology is as follows:

1. Set the train going at the desired speed
2. Busy-poll for sensor updates, logging a line with the sensor + timestamp when a sensor is triggered
    - Line has the format of `R"({"event":"sensor","speed":%hhu,"sensor":"%c%hhu","time":%lu},)"`

3. After \~13 seconds (a fairly arbitrary amount), wait until one-last sensor is triggered
4. Bring the train up to speed 14, and wait for it to hit a particular sensor on the outer loop
5. Send the stop command to halt the train

Steps 4 and 5 are useful to automatically bring the train back to a specific known location on the train set. In fact, the first run of the steady-state velocity test doesn't actually record any data, and is solely performed to "calibrate" the train to an expected state!

### Stopping Distance

<!-- TODO: jams -->

- mention that we didn't collect stop distance for each speed

# Train Measurement - Analysis and Integration

<!-- TODO: jams -->

# Future Work

- The framework is set up, and the possibilities are there. The limiting factor is time!
    - good framework for integrating new measurements
    - (we believe) the primitive is good

- refining and improving measurements
- big code cleanup before next assignment
    - deadlines => write-only code
    - better separation of concerns
    - less C, more C++ isms
    - make the UI nicer at some point???
